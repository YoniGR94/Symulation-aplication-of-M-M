---
title: "My M&M OCD"
author: "Yoni"
date: "`r format(Sys.time(), '%d %m, %Y')`"
output: pdf_document
---

# Intro

### Objective of Simulation

The goal of this simulation is to test the statistics of M&M and other stacks even chocolate lentils by color.

I wanted to know what is the chance of my finishing the package of M&M without mixing any color in one bite, eating them 2 by 2

In addition, here are some BI insights that needed to be checked:

1. What is the probability of M&M packages packaged fairly?

2. What is the probability of M&M packages packaged without one color?

3. How does the size of the package or number of colors affect this probability?


### Method

This report explores the randomness and fairness of color distribution in M&M-style candy packs.  
We simulate hundreds of packages with varying sizes and color counts, then apply statistical analysis  
to understand how often one might get "balanced" packs â€” and what impacts those odds.

I do not have an inner information of how does (M&M)[https://www.mms.com/en-us] make their delicious snacks nor we know how they make sure each package have fair amount of each color. Therefore, the method I chose is based of simulation of some M&M bags, according to the most common sizes of packages.

Each time we sample x lentils(units of M&M), name them by colors (V1,V2...), and see the results for many packages as a statistic data.

My hypothesis is that the probability of perfect package (aka a package with all colors number been even) is very small, at least for a standard 6 colors pack.

### Parameters

Basic parameters:

We define a "pack" as a vector of integers representing the count of each color.  
Each simulation uses random sampling with replacement to mimic real-world packaging.  
Key variables:

- `n-color`: Number of distinct colors

- `n-unit`: Total candies in the pack

```{r}
n= 800              #numbers of bags per sample
n_color= 6          #unique colors of M&M
gram= 0.91          #weight of one M&M
bag_g= 250          #common weight of M&M package
n_unit= bag_g/gram  #M&M per packagenm,
```
```{r packages, message=FALSE, warning=FALSE, echo=FALSE}
library(tidyverse)
library(MASS) #calculate distribution parameters
library(scales)
```
```{r parameters, error=FALSE, warning=FALSE, echo=FALSE}
#parameters
n<- 800            #numbers of bags per sample
n_color<- 6         #unique colors of M&M
gram<- 0.91         #weight of one M&M
bag_g<- 250         #common weight of M&M package
n_unit<- bag_g/gram #M&M per packagenm,
av_per_color= n_unit/n_color
paste0("The avarage number of lentils per color is ", round(av_per_color,2))
```

# Creating the Sample

## General Sample

In order to test the theoretical data, I need to simulate it using customize functions. here are there:

* `Create_bag`- function to create one snack package for chosen package size and number of colors.

* `sample_MnM`- function to create n bags from the Create_bag function.

key parameters for `sample_MnM`

- `n`: Number of packages in the sample

- `x_units`: Total candies in each package

- `t_colors`: Number of distinct colors in each package

```{r sampling functions, error=FALSE, warning=FALSE, echo=F}
Create_bag<- function(x,tx) #create bag using sample vector
  {
  x<- floor(x)+sample(0:1,1)
  res<- matrix(nrow = 1, ncol = tx)
  colnames(res)<- 1:tx
  S_res<- sample(tx,x,replace = T)
  while(sum(table(S_res)>x))
  {S_res<- S_res[-1]}
  for (i in 1:tx) {
    res[,i] <- sum(S_res==i)
    }
  res}

sample_MnM<-function(n,x_units,t_colors) #create n bag using sample vector
  {
  res<- matrix(nrow = n, ncol = t_colors)
  for (i in 1:n)
    {res[i,]<- Create_bag(x= x_units,tx=t_colors)}
  res}
```
```{r sample example, error=FALSE, warning=FALSE, echo=FALSE}
#example
print("One bag of 100:")
Create_bag(100,6)
print("3 bags of 100:")
sample_MnM(3,100,6) %>% 
   `colnames<-`(c(1:6)) %>% 
   `rownames<-`(c("Bag_1","Bag_2","Bag_3")) %>% 
   `colnames<-`(c("Red","Blue","Green", "Orange", "Yellow", "Brown"))
```

## Preview Graph

Now will be creating n bugs of M&M

columns:

1. `V1:V6`- the number of lentils per color

2. `even_count`- how many evens colors there are

3. `even_evens`- are the uneven colors even

4. `Variance`- variance of lentils per color

5. `low_col`- sum true if one color's count is lower than $\frac{2}{3}$ of expected value

6. `min`- the lowest color in each row

here are the first rows:

```{r creating the bag, warning=FALSE, error=FALSE, echo=FALSE}
MnM_sample<- sample_MnM(n,n_unit,n_color) %>% 
     `colnames<-`(c("Red","Blue","Green", "Orange", "Yellow", "Brown"))

MnM_sample<-
  MnM_sample %>% as_data_frame() %>% 
  mutate(even_count= rowSums(across(everything()  , ~ .x %% 2 == 0)), #how many evens colors there are
         even_evens= rowSums(across(c(1:6), ~ .x %% 2 == 1)) %% 2 ==0, #are the uneven colors even
         low_col=    rowSums(across(c(1:6), ~ .x <= 0.66*av_per_color)),
         Variance=    apply(across(c(1:6)), 1, var), #var of candy per color/ type
         min=        apply(across(c(1:6)),1,FUN = min), # lowest value in color
         all_even=   rowSums(across(c(1:n_color)  , ~ .x %% 2 == 0))== n_color)



knitr::kable(MnM_sample %>% head(4), caption = "M&M sample random rows")
```

plot the M&M sample summary

```{r ggplot 1 sample, warning=FALSE, error=FALSE, echo=F}
colors_summary_df<-rbind(
  MnM_sample$Red %>% summary(),
  MnM_sample$Blue %>% summary(),
  MnM_sample$Green %>% summary(),
  MnM_sample$Orange %>% summary(),
  MnM_sample$Yellow %>% summary(),
  MnM_sample$Brown %>% summary()) %>%
  as.data.frame() %>% cbind(sapply(MnM_sample[,1:6],var,na.rm=1)) %>% 
  rename("Var" ="sapply(MnM_sample[, 1:6], var, na.rm = 1)")

knitr::kable(colors_summary_df, caption = "summary of all colors Distibution")

MnM_sample %>%
  mutate(is.even = even_count %%2 ==0) %>% 
  ggplot(aes(x= even_count, fill= is.even))+
  geom_bar()+
    geom_text(stat = "count",
    aes(label = ..count..),vjust = -0.5)+
  labs(title="Distibution of Eveness of Colors")

MnM_sample %>%
  mutate(is.even = Red %%2 ==0) %>% 
  ggplot(aes(x= Red, fill= is.even))+
  scale_fill_manual(values = c("red", "red4"))+
  geom_bar()+labs(title="Distibution of the Red Color")+
  theme(panel.grid = element_line(color = "gray50"))
```

## Statisics Checking of the Simullation

### Test Expected Value

to see is the $\mu$ of the lentils per color are fair, I will test it per column with t.test for each color.

Here is the result, none of them bellow 5% P. value

p.value of $H_0: \mu= \frac{n_unit}{n_color}$
```{r t test mu, echo=FALSE}
#test mu is av_per_color
check_mean_hypothesis <- function(data, column_name, X)
  {
  test_result <- t.test(data[[column_name]], mu = X)
  test_result$p.value}

columns_to_test <- colnames(MnM_sample[,1:6])
test_results <- sapply(columns_to_test, function(col) {
  check_mean_hypothesis(MnM_sample, col, av_per_color)})

percent(test_results)
```

Now I will do the same checking for 2 samples, to see whether there is correlation between each 2 colors distribution.

for each row i and column j,
1) if i==j, this it the check from before of the expected value to n_unit/n_color
2) if i!=j, this is two samples test of same expected value hypothesis

```{r P.value test, echo=FALSE}
check_mean_hypothesis <- function(data, column_name, X) {
  t.test(data[[column_name]], mu = X)$p.value}

check_two_sample_t_test <- function(data, col1, col2) {
  t.test(data[[col1]], data[[col2]])$p.value}

columns_to_test <- colnames(MnM_sample[,1:6])
num_cols <- length(columns_to_test)
p_value_matrix <- matrix(NA, nrow = num_cols, ncol = num_cols, dimnames = list(columns_to_test, columns_to_test))
for (i in 1:num_cols) {
  for (j in 1:num_cols) {
    if (i == j) { #diagonal test of mu
      p_value_matrix[i, j] <- check_mean_hypothesis(MnM_sample, columns_to_test[i], av_per_color)
    } else { # 2 sample t.test
      p_value_matrix[i, j] <- check_two_sample_t_test(MnM_sample, columns_to_test[i], columns_to_test[j])
    }
  }
}

round(as.data.frame(p_value_matrix),3) %>%
  mutate(color_1= rownames(p_value_matrix)) %>% 
  pivot_longer(cols = 1:6, names_to = "color_2", values_to = "t_test") %>% 
  mutate(Reject_H0 = t_test<= 0.05) %>% 
  ggplot(aes(x= color_1, y= color_2))+
  geom_text(aes(label = sprintf("%.1f%%", t_test * 100), color = Reject_H0), size = 4)+
  labs(title="Colors Correlation Map", color = "Reject Ho",
       x = "Color 1",
       y = "Color 2")+
  theme_classic()
```
Now here Is visualization of the actual data per color

```{r plot 2 colors, warning=FALSE, error=FALSE, echo=F, message= F}
colored_MnM<- MnM_sample %>%
    pivot_longer(cols = 1:6, names_to = "Color", values_to = "pieces") %>%
    ggplot(aes(fill=Color ,x= pieces))+
  geom_histogram(position = "identity", alpha= 0.8)+
    scale_fill_manual(values = c("blue", "chocolate4","green4", "orange3","red4", "yellow2"))+
  theme(panel.grid = element_line(color = "grey50",
                                  size = 0.75))+facet_wrap(~Color)

ggsave(colored_MnM, 
       filename = "colored_M&M.png",
       height = 4, width = 5, units = "in")

colored_MnM
```

### Variance Distribution Checking

I know that the distribution of variance is approximately Gamma distribution:

$$f(x) = \frac{1}{\Gamma(\alpha)\theta^\alpha} x^{\alpha-1}e^{-x/\theta}$$

I can see that the variance distribution is Gamma like with shape and rate as seen below

```{r, warning=FALSE, error=FALSE, echo=F}
gamma_params <- fitdistr(MnM_sample$Variance, "gamma")$estimate
paste0("The parameters of the gamma shaped variance is shape ", round(gamma_params[1],3)," and rate ", round(gamma_params[2],3) )
shape_est <- gamma_params["shape"]
scale_est <- 1 / gamma_params["rate"] #using Scale= 1/Rate

MnM_sample %>% #plot density
  ggplot(aes(x = Variance)) +
  geom_density(fill= "skyblue3", alpha= 0.8) +
  geom_vline(xintercept = mean(MnM_sample$Variance), color = "blue", size=1) +
  geom_vline(xintercept = scale_est*shape_est, color = "red", linetype = "dashed", size=1) +
  stat_function(fun = dgamma, args = list(shape = shape_est, scale = scale_est), 
                color = "red3", alpha= 0.7) +
  labs(title = "Density Plot with Gamma Distribution",
       x = "Variance",
       y = "") +
  scale_y_continuous(label=scales::label_percent(.1)) + 
  theme_minimal()
```

### Are All Even in the Sample?

```{r are all even, warning=FALSE, error=FALSE, echo=F}
MnM_sample %>%
  select_(1,2,3,4,5,6) %>%
  mutate(count_even = rowSums(across(1:n_color, ~ .x %% 2 == 0))) %>%
  count(count_even) %>%
  ggplot(aes(x = factor(count_even), y = n, fill = n)) +  # make x categorical
  geom_bar(stat = "identity", color= "grey20") +
  scale_fill_gradient(low = "skyblue", high = "green2") +
  labs(
    title = "Count of Even Colors per Row",
    x = "No. Even Rows",
    y = "Packages"
  )+
    geom_text(aes(label = n), color = "black", size = 4,vjust = -0.5)+
  theme_minimal()
```

### n*m types of snacks

I will create a function that create sample for each number of colors and package size I want, and then calculate some interesting parameters

```{r function multy-sample, warning=FALSE, error=FALSE, echo=F}
mega_snack<- function(nn,n_unit,n_color)
  {
  m_sample<- length(n_unit)*length(n_color)
  nul_mat= matrix(nrow = m_sample, ncol = 6)
  res<- cbind(rep(n_unit,length(n_color)),
              sort(rep(n_color,length(n_unit))),
              nul_mat)
    colnames(res)<- c("n_unit", "n_color", "even_count", "even_evens",
                    "var_col","all_even","low_color","smallest_col")
    for (i in 1:(dim(res)[1]))
  {
    low_color<- 0.666*res[i,1]/(res[i,2])
    small_sample<- sample_MnM(nn,res[i,1],res[i,2])%>%
      as_data_frame() %>% 
      mutate(even_count= rowSums(across(everything()  , ~ .x %% 2 == 0))/res[i,2],
             #how many evens colors there are
             even_evens= (rowSums(across(c(1:n_color)  , ~ .x %% 2 == 1)) %% 2 ==0)/res[i,2],
             #are the uneven colors even
             var_col=     apply(across(c(1:n_color)), 1, var),
             #var of candy per color/ type
             smallest_col=apply(across(c(1:n_color)), 1, min),
             #lowest value in color
             #all_even=    rowSums(across(c(1:n_color), ~ .x %% 2 == 0)) >= res[i,2],
             all_even=    even_count >= 1,
             low_color=   rowSums(across(c(1:n_color), ~ .x <= low_color ))>=1
            )
    res[i,3:8]<- c(
      mean(small_sample$even_count),
      mean(small_sample$even_evens),
      mean(small_sample$var_col),
      mean(small_sample$all_even,  na.rm = T),
      mean(small_sample$low_color),
      min(small_sample$smallest_col))
      }

  res %>% as.data.frame()
}
```

I will make the multiple sample. parameters:

```{r Data for multiple sample, warning=FALSE, error=FALSE}
n_color<- 2:8 #Number of distinct colors in each package option
grams_op<- c(25,45,150,250,330,500,750,1000) #Weight of each package option
n_unit_op<- grams_op/gram #Total candies in each package option
nn<- 800 #Number of packages in the sample
```

Here is some random rows:
```{r baking multiple sample, warning=FALSE, error=FALSE, echo= F}
mega_snack_1<-
  mega_snack(nn,n_unit_op,n_color) %>%
  mutate(n_unit= round(n_unit,1))

knitr::kable(mega_snack_1 %>% sample_n(5) %>% 
             mutate_at(3:7, round, 3),
             caption = "Multiple sample example rows")
```

## Deep Insight on the Data

here are some insights:

```{r hitmap, warning=FALSE, error=FALSE, echo=F}
mega_snack_1 %>%
  ggplot(aes(x = factor((round( n_unit,1) )), y = factor(n_color ), fill = even_count)) +
  geom_tile(color= "black") +
  scale_fill_gradient(low = "orange", high = "skyblue")+
  labs(title = "avarage even count percent by number of colors and units",
       x= "Lentils",
       y= "No. of colors",
       fill= "even count") +
    geom_text(aes(label = round(even_count,2)), color = "coral4", size = 4)+
  guides(colour= "none")+
  theme_minimal()
```


```{r hitmap_2, warning=FALSE, error=FALSE, echo=F}
mega_snack_1 %>%
  ggplot(aes(x = factor((round( n_unit,1) )), y = factor(n_color ), fill = even_evens )) +
  geom_tile(color= "black") +
  scale_fill_gradient(high = "deepskyblue", low = "coral4")+
  labs(title = "Does the Uneven Colors Even",
       x = "Lentils",
       y = "No. of colors",
       fill = "even evens") +
  geom_text(aes(label = round(even_evens,2)), color = "black", size = 4)+
  theme_minimal()
```

Here is probability of all even, and whether there is pattern.

```{r ggplot all even, warning=FALSE, error=FALSE, echo=F}
Heatmap_all_evens<-
  mega_snack_1 %>%
  ggplot(aes(x = as.factor(round( n_unit,1) ), y = n_color , color = all_even)) +
  geom_point(size = 8 ) +
  scale_color_gradient(low = "yellow", high = "darkolivegreen3")+
  labs(title = "Were all Colors Evens",
       x = "Lentils",
       y = "No. of colors",
       color = "all even") +
        geom_text(aes(label = sprintf("%.1f%%", all_even * 100)), color = "black", size = 3)+
    guides(size= "none")+
  theme_bw()

ggsave(Heatmap_all_evens, 
       filename = "Heatmap_all_evens.png",
       height = 4, width = 5, units = "in")
  guides(colour= "none")

Heatmap_all_evens
```

```{r ggplot missing color, warning=FALSE, error=FALSE, echo=F}
mega_snack_1 %>%
  ggplot(aes(x = factor(round(n_unit, 1)), y = n_color, fill = low_color))+
  geom_tile(color = "white") +
    geom_text(aes(label = sprintf("%.2f%%", low_color * 100)), color = "black", size = 4)+
  scale_fill_gradient(low = "darkolivegreen3", high = "purple3",labels = scales::percent)+
  labs(title = "Chance of Less Than 66% Color in Package",
       x = "Lentils",
       y = "No. of colors",
       fill = "low color")+
  theme_minimal()
```
Here we can see the smallest % of Lentils in one color as seen in my sample:

```{r smallest color vs expected, warning=FALSE, error=FALSE, echo=F}
mega_snack_1 %>% 
  select_(1,2,8) %>% 
  mutate(smallest_to_mu= smallest_col*n_color/n_unit) %>%
   ggplot(aes(x = factor(round(n_unit, 1)), y = n_color, fill = smallest_to_mu))+
  geom_tile(color = "white") +
    geom_text(aes(label = sprintf("%.1f%%", smallest_to_mu * 100)), color = "black", size = 4)+
  scale_fill_gradient(low = "red3", high = "darkolivegreen3",labels = scales::percent)+
  labs(title = "Smallest Color as Percent of Expected Value",
       x = "Lentils",
       y = "No. of colors",
       fill = "% of Expected Value")+
  theme_bw()
```

As we can see, only the small package (less than 50 lentils) have high probability of at least one color to appear severely lower.

Therefore, splitting package by color on the big ones should be relatively even.

### using regression for correlation check

```{r regression, warning=FALSE, error=FALSE, echo=F}
mega_snack_open<- function(nn,n_unit,n_color)
  {
  m_sample<- nn*length(n_unit)*length(n_color)
  nul_mat= matrix(nrow = m_sample, ncol = 2)
  res<- cbind(rep(n_unit,nn*length(n_color)),
         sort(rep(n_color,nn*length(n_unit))),
              nul_mat)
  for (i in 1:(dim(res)[1]))
  {
    low_color<- 0.666*res[i,1]/(res[i,2])
    small_sample<- Create_bag(res[i,1],res[i,2])%>%
      as_data_frame() %>% 
      mutate(even_count= rowSums(across(everything()  , ~ .x %% 2 == 0))/res[i,2],
             all_even=   rowSums(across(c(1:n_color)  , ~ .x %% 2 == 0))== res[i,2],
            )
    res[i,3]<- mean(small_sample$even_count)
    res[i,4]<- mean(small_sample$all_even)
      }
  colnames(res)<- c("n_unit", "n_color", "even_count","all_even")
  res %>% as.data.frame()
  }

mega_snack_2<- mega_snack_open(20,n_unit_op,n_color) %>% 
  mutate(color_No2= n_color %%2 == 0) #check if the number of colors is even

lm_color<- lm(mega_snack_2$even_count~ mega_snack_2$n_color +mega_snack_2$n_unit)
lm_color %>% summary()

lm_color_all<- lm(mega_snack_2$all_even~ mega_snack_2$n_color +mega_snack_2$n_unit+ mega_snack_2$color_No2)
lm_color_all %>% summary()
```

Seeing  the $2_{nd}$ regression we can suggest that more colors is correlated with 3.3% less probability of all colors even,
while even numbers of colors is correlated with 7.7% more probability of all colors eve, regardless of any package size.

# Conclusions

### Data Structure

The simulation created a random samples of snack packs, which was proven to be statistically random with known $\mu$ and $\sigma^2$. I created one sample with specific size and numbers of colors using "sample_MnM", and costume multiple samples using "mega_snack". Then, I check the relevand indicators fot this project.

I found out that:

* Small packages often lack at least one color, and sometimes contain only one color.

* As the number of colors increases, the chance that all colors have even counts drops significantly.

* For medium to large packages, the probability of any one color being significantly underrepresented (less than $\frac{2}{3}$ of its expected amount) is near zero.

suggestion for any random sampler factory (like candies, lego, toys):

1. Smaller packages need more diversity check

2. Althernatively, I would recomand calculate the amount of each type in small packages

### Main Q: Eating M&M by Two

Although there is no clear pattern to the right M&M package for all the colors to have even count,
different approach might find a clear reason for more or less couples of M&M. Here is what I did found:

The general probability of all colors to be even in 6 colored pack is 1.5% for small 50g package 2.1% for big 1000g package, and overall 1.5%, which is more than I expected.

For 5 colored pack like Skittles the average is about 2.9%

For 2 colored pack the average is 24.5%, so for 2 colored marshmallow bag this will be the statistics.

See all here:
```{r summary knitr, warning=FALSE, error=FALSE, echo=F}
summary_table<-
  mega_snack_1 %>%
  rename(Colors= n_color) %>% 
  group_by(Colors) %>% 
  summarise('All Even Percent'= round(mean(all_even)*100,2) ,
            .groups = 'drop') %>%
  as.data.frame()
knitr::kable(summary_table, caption = "Probability of All Colors Even by Pack Colors Number")
```

### Summary

To sum it up, for each medium pack the probability of all even colors is 1.4%, or 1 in a 73 packs of 250g. So I might need to change my snack preference to marshmallow if I want to keep this method.

This project allowed me to implement simulation methods in response to a real (albeit silly) question, and evaluate it statistically from end to end..

I applied:

* Simulation logic

* Exploratory analysis

* Hypothesis testing

* Distribution checks

* Outlier detection

* Visualization using R

In addition, I created the infrastructure for similar questions with different parameters to be checked in a reusable, structured way.


